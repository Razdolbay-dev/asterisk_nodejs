const fs = require('fs').promises;
const path = require('path');
const config = require('../../config/app');

class QueuesGenerator {
    constructor() {
        this.configPath = path.join(__dirname, '../../../', config.paths.generated);
    }

    // Безопасная запись файла
    async safeWriteFile(filename, content) {
        const tempPath = path.join(this.configPath, `${filename}.tmp`);
        const finalPath = path.join(this.configPath, filename);

        try {
            await fs.writeFile(tempPath, content, 'utf8');
            await fs.rename(tempPath, finalPath);
            console.log(`✅ Queue config saved: ${filename}`);
        } catch (error) {
            try {
                await fs.unlink(tempPath);
            } catch (unlinkError) {}
            throw error;
        }
    }

    // Генерация конфига для очереди
    generateQueue(queueConfig) {
        const {
            id,
            name,
            strategy = 'ringall',
            timeout = 30,
            wrapuptime = 10,
            maxlen = 0,
            servicelevel = 60,
            members = [],
            musicclass = 'default',
            announce = 'queue-thankyou'
        } = queueConfig;

        let configContent = `
; Generated by AsteriskGUI - ${new Date().toISOString()}
; Queue: ${name}

[${id}]
strategy=${strategy}
timeout=${timeout}
wrapuptime=${wrapuptime}
maxlen=${maxlen}
servicelevel=${servicelevel}
musicclass=${musicclass}
announce=${announce}
`.trim();

        // Добавляем участников очереди
        members.forEach((member) => {
            configContent += `\nmember => ${member.interface}`;
            if (member.penalty) {
                configContent += `,${member.penalty}`;
            }
            if (member.membername) {
                configContent += `,${member.membername}`;
            }
        });

        return configContent;
    }

    // Генерация полного queues.conf
    async generateFullQueuesConfig(queues) {
        let configContent = `; Generated by AsteriskGUI - ${new Date().toISOString()}\n`;
        configContent += `; DO NOT EDIT MANUALLY - Changes will be overwritten\n\n`;

        // Общие настройки
        configContent += `[general]\n`;
        configContent += `persistentmembers=yes\n`;
        configContent += `autofill=yes\n`;
        configContent += `monitor-type=MixMonitor\n`;
        configContent += `monitor-format=wav\n`;
        configContent += `shared_lastcall=yes\n`;
        configContent += `maxlen=100\n\n`;

        // Добавляем все очереди
        for (const queue of queues) {
            configContent += this.generateQueue(queue) + '\n\n';
        }

        return configContent;
    }

    // Сохранение полного queues.conf
    async saveQueuesConfig(queues) {
        const configContent = await this.generateFullQueuesConfig(queues);
        await this.safeWriteFile('queues.conf', configContent);
        return configContent;
    }

    // Генерация конфига для участников очереди (queues.conf)
    generateQueueMembers(members) {
        let configContent = `; Generated by AsteriskGUI - ${new Date().toISOString()}\n\n`;

        members.forEach((member) => {
            configContent += `[queue_member]\n`;
            configContent += `interface=${member.interface}\n`;
            if (member.queue) configContent += `queue=${member.queue}\n`;
            if (member.penalty) configContent += `penalty=${member.penalty}\n`;
            if (member.membername) configContent += `membername=${member.membername}\n`;
            configContent += `\n`;
        });

        return configContent;
    }
}

module.exports = new QueuesGenerator();