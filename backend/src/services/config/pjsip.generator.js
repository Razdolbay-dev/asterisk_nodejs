const fs = require('fs').promises;
const path = require('path');
const config = require('../../config/app');

class PJSIPGenerator {
    constructor() {
        this.configPath = path.join(__dirname, '../../../', config.paths.generated);
        this.ensureConfigDirectory();
    }

    // Создание директории если не существует
    async ensureConfigDirectory() {
        try {
            await fs.access(this.configPath);
        } catch (error) {
            await fs.mkdir(this.configPath, { recursive: true });
            console.log(`✅ Created config directory: ${this.configPath}`);
        }
    }

    // Безопасная запись файла (atomic write)
    async safeWriteFile(filename, content) {
        const tempPath = path.join(this.configPath, `${filename}.tmp`);
        const finalPath = path.join(this.configPath, filename);

        try {
            // Записываем во временный файл
            await fs.writeFile(tempPath, content, 'utf8');
            // Атомарно перемещаем в конечный файл
            await fs.rename(tempPath, finalPath);
            console.log(`✅ Config file saved: ${filename}`);
        } catch (error) {
            // Удаляем временный файл в случае ошибки
            try {
                await fs.unlink(tempPath);
            } catch (unlinkError) {
                // Игнорируем ошибку удаления временного файла
            }
            throw error;
        }
    }

    // Генерация конфига для SIP аккаунта
    generateSIPAccount(sipAccount) {
        const { id, password, context = 'internal', codecs = 'ulaw,alaw' } = sipAccount;

        return `
; Generated by AsteriskGUI - ${new Date().toISOString()}
; SIP Account: ${id}

[${id}]
type=endpoint
context=${context}
disallow=all
allow=${codecs}
auth=${id}
direct_media=no
force_rport=yes
rewrite_contact=yes
rtp_symmetric=yes
ice_support=yes
use_avpf=yes
media_encryption=dtls
dtls_verify=fingerprint
dtls_setup=active
dtls_cert_file=/etc/asterisk/keys/asterisk.pem
dtls_private_key=/etc/asterisk/keys/asterisk.pem
dtls_ca_file=/etc/asterisk/keys/ca.crt
transport=transport-udp

[${id}]
type=auth
auth_type=userpass
password=${password}
username=${id}

[${id}]
type=aor
max_contacts=1
remove_existing=yes

[${-id}]
type=identify
endpoint=${id}
match=192.168.88.0/24

`.trim();
    }

    // Генерация транспортного конфига
    generateTransportConfig() {
        return `
; Generated by AsteriskGUI - ${new Date().toISOString()}
; UDP Transport

[transport-udp]
type=transport
protocol=udp
bind=0.0.0.0

`.trim();
    }

    // Генерация полного pjsip.conf из всех аккаунтов
    async generateFullPJSIP(sipAccounts) {
        let configContent = `; Generated by AsteriskGUI - ${new Date().toISOString()}\n`;
        configContent += `; DO NOT EDIT MANUALLY - Changes will be overwritten\n\n`;

        // Добавляем транспорт
        configContent += this.generateTransportConfig() + '\n\n';

        // Добавляем все SIP аккаунты
        for (const account of sipAccounts) {
            configContent += this.generateSIPAccount(account) + '\n\n';
        }

        return configContent;
    }

    // Сохранение полного pjsip.conf
    async savePJSIPConfig(sipAccounts) {
        const configContent = await this.generateFullPJSIP(sipAccounts);
        await this.safeWriteFile('pjsip.conf', configContent);
        return configContent;
    }

    // Сохранение отдельных SIP аккаунтов как отдельных файлов
    async saveIndividualSIPConfig(sipAccount) {
        const configContent = this.generateSIPAccount(sipAccount);
        const filename = `pjsip_${sipAccount.id}.conf`;
        await this.safeWriteFile(filename, configContent);
        return configContent;
    }
}

module.exports = new PJSIPGenerator();